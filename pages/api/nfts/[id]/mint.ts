import { NextApiRequest, NextApiResponse } from 'next';
import { getToken } from 'next-auth/jwt';
import { readFile } from 'fs/promises';
import { ethers, Wallet } from 'ethers';
import pinataSDK from '@pinata/sdk';
import { concat, toUtf8Bytes } from 'ethers/lib/utils';
import getConfig from 'next/config';

const pinata = new pinataSDK(
  process.env.NEXT_PINATA_API_KEY,
  process.env.NEXT_PINATA_API_SECRET
);

type Data = {
  err: boolean;
  msg: string | { image: string; messageLength: string; sig: string };
};

type ImageData = {
  image: string;
  description: string;
  name: string;
  attributes: {
    num_inference_steps: string;
    guidance_scale: string;
  };
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  switch (req.method) {
    case 'POST':
      try {
        const token = await getToken({ req });
        const { publicRuntimeConfig } = getConfig();

        if (!token || !token.sub) {
          return res
            .status(403)
            .json({ err: true, msg: 'You are not authorized!' });
        }

        if ((req.query.id as string).length > 100) {
          return res.status(413).json({ err: true, msg: 'Id is too long!' });
        }

        if (!/^[a-zA-Z0-9]*$/g.exec(req.query.id as string)) {
          return res.status(412).json({
            err: true,
            msg: 'Id is malformed!',
          });
        }

        if (
          !req.body.extension ||
          !/^\.[a-zA-Z0-9]+$/.exec(req.body.extension.trim())
        ) {
          return res.status(412).json({
            err: true,
            msg: 'Extension is malformed!',
          });
        }

        if (!publicRuntimeConfig?.networksToAddresses[req.body.chainId]?.name) {
          return res
            .status(404)
            .json({ err: true, msg: 'Network is not supported!' });
        }

        const rawImageJson = await readFile(
          `./public/generated/jsons/${req.query.id}.json`,
          {
            encoding: 'utf8',
          }
        );
        const imageJson = JSON.parse(rawImageJson);

        const creatorAddress: string = imageJson.address;

        if (token.sub !== creatorAddress) {
          return res.status(403).json({
            err: true,
            msg: "Owner of the generated image doesn't collate with a logged in user! Check your account!",
          });
        }

        if (!(await pinata.testAuthentication()).authenticated) {
          throw new Error("Server can't connect to ipfs!");
        }

        const imageIpfsHash = (
          await pinata.pinFromFS(
            `./public/generated/images/${req.query.id + req.body.extension}`,
            {
              pinataMetadata: { name: req.query.id + req.body.extension },
            }
          )
        ).IpfsHash;

        const jsonIpfsProperties: ImageData = {
          image: 'ipfs://' + imageIpfsHash,
          name: imageJson.prompt,
          description:
            'Diffused NFTs are generated by AI. Signature to mint generated image ' +
            'is issued by the server. Users are prompted to generate, mint and sell as much NFT as they want!',
          attributes: {
            num_inference_steps: imageJson.num_inference_steps,
            guidance_scale: imageJson.guidance_scale,
          },
        };

        const jsonIpfsHash = (
          await pinata.pinJSONToIPFS(jsonIpfsProperties, {
            pinataMetadata: { name: req.query.id + '.json' },
          })
        ).IpfsHash;

        const provider = new ethers.providers.JsonRpcProvider(
          process.env.NEXT_JSON_RPC_URL,
          publicRuntimeConfig.networksToAddresses[req.body.chainId].name
        );

        const wallet = new Wallet(process.env.NEXT_SECRET!, provider);
        const message = concat([
          toUtf8Bytes(jsonIpfsHash),
          creatorAddress,
          toUtf8Bytes(
            publicRuntimeConfig.networksToAddresses[req.body.chainId].name
          ),
        ]);
        console.log(
          jsonIpfsHash,
          creatorAddress,
          publicRuntimeConfig.networksToAddresses[req.body.chainId].name
        );
        const imageSignature = await wallet.signMessage(message);

        res.status(200).json({
          err: false,
          msg: {
            image: jsonIpfsHash,
            messageLength:
              '0x' + Buffer.from(String(message.length)).toString('hex'),
            sig: imageSignature,
          },
        });
      } catch (err) {
        if (err instanceof Error) {
          if (err.message.includes('no such file or directory'))
            return res.status(404).json({ err: true, msg: 'Image not found' });

          res.status(500).json({ err: true, msg: err.message });
        } else {
          res.status(500).json({ err: true, msg: err as any });
        }
      }
      break;
    default:
      res.setHeader('Allow', ['POST']);
      res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}
